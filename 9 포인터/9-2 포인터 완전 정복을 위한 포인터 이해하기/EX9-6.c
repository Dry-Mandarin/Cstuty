#include <stdio.h>

int main(void)
{
	int a = 10;
	int* p = &a;
	double* pd;

	pd = p;
	printf("%lf\n", *pd);

	return 0;
}
/*
포인터의 대입 규칙
1. 포인터는 가리키는 변수의 형태가 같은 떄만 대입해야 한다.
   포인터 끼리 대입 연산을 수행하면 여러 개의 포인터로 같은 데이터를 다루는 것이 가능하다. 그러나 규칙을 지키지 않는 대입 연산은 그 겨로가를 예상할 수 없다.

   6행의 변수 p와 7행의 pd는 모두 포인터지만 가리키는 자료형이 다르다
	int* p = &a;  <-6행. 포인터 선언과 동시에 a를 가리키도록 초기화
	double* pd;   <-7행. double형 변수를 가리키는 포인터
   즉, 컴파일러는 p에 저장된 값을 int형 변수의 주소로 생각하고, pd에 저장된 값을 double형 변수의 주소로 생각한다.
   따라서 pd에 p를 대입한 후에 간접 참조 연산ㅇ르 수행하면 변수 a에 할당된 영역 이후의 할당되지 않은 영역까지 사용하게 된다.

2. 형 변환을 사용한 포인터의 대입은 언제가 가능하다
   포인터가 가리키는 자료형이 다른 경우라도 형 변호나 연산자를 사용하면 경고 메시지 없이 대입할 수 있다. 
   단 대입한 후에 포인터를 통한 사용에 문제가 없어야 한다.
     


	 double a = 3.4;   //double형 변수 선언
	 double #pd = &a;  // pd가 double형 변수 a를 가리키도록 초기화
	 int* pi;          //int형 변수를 가리키는 포인터
	 pi = (int*)pd;    //pd 값을 형 변환해 pi에 대입

 여기서 pi에 간접 참조 연산을 수행하면 변수 a의 일부를 int형 변수처럼 사용할 수 있다
 이런 사용 방법은 포인터로 메모리르 ㄹ직접 쪼개 쓰는 것이므로 데이터가 메모리에 저장되는 방식을 충분히 이해해야한다
 만약* pi = 10;과 같이 a의 일부분에 정수를 저장하면 정수와 실수의 데이터 크기와 저장 방식이 다르므로 a에 저장한 실수 값은 사용할 수 없다.
  
*/
